{
    "collab_server" : "",
    "contents" : "library(ggplot2)\nlibrary('Matrix')\nrequire('TTR')\nrequire('igraph')\nrequire('survey')\nrequire('grr')\nlibrary(MASS)\nrequire('numDeriv')\nrequire('mvtnorm')\n\n# load data\nif (TRUE) {\n  load(\"data_exec/Xt_real.RData\")\n  load(\"data_exec/m.time.RData\")\n  load(\"data_exec/obs.matrix.RData\")\n  load('data_prep/person.state.d.RData')\n  load('data_exec/Yt.RData')\n  load('data_exec/S2.RData')\n}\n\n#obs.matrix,mu.obs, Yt scale 2\nif (TRUE) {\n  obs.matrix = exp(obs.matrix)\n  colnames(obs.matrix) = c(1:ncol(obs.matrix))\n  rownames(obs.matrix) = c(1:nrow(obs.matrix))\n  N = nrow(obs.matrix)\n  mu.obs = array(0,dim = N)\n  mu.obs = apply(obs.matrix, 1, function(x) sum(x*c(1:ncol(obs.matrix)-1)))\n  var.obs = array(0,dim = N)\n  var.tmp = matrix(rep(c(1:ncol(obs.matrix)-1),each=nrow(obs.matrix)),nrow = nrow(obs.matrix))\n  var.tmp = apply(var.tmp, 2, function(x) x-mu.obs)\n  var.tmp = var.tmp^2\n  var.obs = rowSums(var.tmp*obs.matrix)\n}\n\n\n### method 3: to construct Kalman filter\n\n#EKF = function(Y, f, h, dfdX, dhdX, Q, R, X0, P0)\n# updating R\nif (TRUE) {\n    scale = 10\n    time.th = 231-2\n    obs.lanes = c(1:ncol(Xt_real))\n    from.to = cbind(which(S==-1, arr.ind=TRUE)[,1],which(S==1, arr.ind=TRUE)[,1])\n    \n    #input\n    Y=Yt[,obs.lanes]*1\n    f = function(t, X, W=0, Theta) X+S%*%(m.time[cbind(from.to ,min(trunc((t+time.th)/60)-2,23))]*X[which(S==-1, arr.ind=TRUE)[,1]])\n    h = local(function(t, X, W=0, Theta) C %*% X/scale, envir=list(C=diag(nrow(S))[obs.lanes,]))\n    Q=function(t, X, W, Theta){\n      val_diag <- m.time[cbind(from.to ,min(trunc(t/60)+1,24))]*X[which(S==-1, arr.ind=TRUE)[,1]]\n      val_S <- sweep(S,2,STATS = val_diag,FUN = '*')\n      return(val_S %*% t(S))\n      #S %*% diag(m.time[cbind(from.to ,min(trunc(t/60)+1,24))]*X[which(S==-1, arr.ind=TRUE)[,1]]) %*% t(S) \n    }\n    R= function(t, X, W, Theta) {\n        #R_matrix = diag(length(obs.lanes))*2\n        value = var.obs[abs(X)+1]\n        value = var.obs[pmin( round(abs(X)+2), length(var.obs))]\n        diag(value,length(obs.lanes),length(obs.lanes))\n    }\n    X0=c(Xt_real[1,])\n    P0=diag(nrow(S))*.1\n    \n    #EKF\n    K = matrix(0,nrow=length(X0),ncol=ncol(Y)) # Kalman gain\n    mu.update = mu.predict = matrix(0, ncol=length(X0), nrow=nrow(Y))\n    mu.update[1,] = mu.predict[1,] = X0\n    F = P.predict = P.update = array(0, dim=c(length(X0),length(X0)))\n    P.predict = P.update = P0\n    \n    #dfdX = function(t, X, W, Theta)\n    #  jacobian(function(X, t, W, Theta) f(t, X, W, Theta), X, t=t, W=W, Theta=Theta)\n    #dhdX = function(t, X, W, Theta)\n    #  jacobian(function(X, t, W, Theta) h(t, X, W, Theta), X, t=t, W=W, Theta=Theta)\n    \n    dfdX = local({\n      drdx = 0*t(S)\n      ndx = which(S==-1, arr.ind=TRUE)\n      function(t, X, W, Theta){\n        drdx[ndx[,2:1]] <<- m.time[cbind(from.to, min(trunc(t/60)+1,24))]\n        diag(rep(1,nrow(S))) + S %*% drdx\n      }\n    })\n    dhdX = local(function(t, X, W=0, Theta) C /scale, envir=list(C=diag(nrow(S))[obs.lanes,]))\n    \n    \n    for(i in 2:nrow(Y)){\n        print(i)\n        F = dfdX(i, mu.update[i-1,])\n        H = dhdX(i, mu.update[i-1,])\n        mu.predict[i,] = f(i, mu.update[i-1,])\n        P.predict = F %*% P.update %*% t(F) + Q(i, mu.update[i-1,])\n        K = P.predict %*% t(H) %*% ginv( H %*% P.predict %*% t(H) + R(i, mu.update[i-1,obs.lanes]))\n        P.update = P.predict - K %*% H %*% P.predict\n        mu.update[i,] = mu.predict[i,] + K %*% (Y[i,]- h(t, mu.predict[i,]))\n    }\n    \n    xyz = list(mu=mu.update, P=P.update, mu.predict=mu.predict, P.predict=P.predict, F=F)\n    saveRDS(mu.update,file='data_result/Xt_ekf.RDS')\n  \n  #test\n  if (FALSE) {\n    plot_lane = 1\n    plot(xyz$P[plot_lane,plot_lane,c(1:1441)],type='l',col='red',log = 'y') \n    \n    load('../../particle_filtering/0_toy/bench_try1/data_exec/Xt_real.RData')\n    time_period = c(1:1441)\n    SMA_scale = 10\n    plot_lane = 1\n    title = paste('EKF observe ',length(obs.lanes),sep=' ')\n    plot(SMA(xyz$mu[time_period,plot_lane],SMA_scale),type='l',col='red',main = title) \n    lines(SMA(Xt_real[time_period,plot_lane],SMA_scale),type='l',col='black')\n    legend('topleft',legend=c('EKF','GT'),col=c('red','black'),lty=c(1,1))\n    \n    name = paste('EKF_ob1&20',plot_lane,sep = '@')\n    name = paste(name,'jpg',sep = '.')\n    dev.copy(file=name, device=jpeg, quality=100, width=1024, height=1024)\n    dev.off()\n  }\n}\n\n#EKS\nEKS = function(Y, F, mu.predict, mu.update, P.predict, P.update){\n  mu = mu.update\n  P = P.update\n  for(i in nrow(Y):2 -1){\n    K = P.update[,,i] %*% t(F[,,i]) %*% solve(P.predict[,,i+1])\n    mu[i,] = mu.update[i,] + K %*% (mu[i+1,]-mu.predict[i+1,])\n    P[,,i] = P.update[,,i] + K %*% (P[,,i+1]-P.predict[,,i+1]) %*% t(K)\n  }\n  list(mu=mu,P=P)\n}\n\nabc = with(xyz, EKS(Y=Yt[,obs.lanes],F=F,mu.predict=mu.predict, mu.update=mu, P.predict=P.predict, P.update=P))\n\nrequire(numDeriv)\n\n\n\n\n\n\n#plot\nif (FALSE) {\n    sample_nums = 10\n    Xt_real = loc.d\n    \n    XT_EKF = xyz$mu\n    sd_EKF = apply(xyz$P, 3, diag)\n    sd_EKF = sqrt(sd_EKF)\n    sd_EKF[is.na(sd_EKF)]=0\n    sd_EKF = t(sd_EKF)\n    Xt_ekf = array(0,dim=c(dim(Xt_real),sample_nums))\n    for (i in c(1:nrow(Xt_real))) {\n        Xt_ekf[i,,]=t(rmvnorm(n=sample_nums,mean = XT_EKF[i,],sigma = diag(sd_EKF[i,])))[1:25,]\n    }\n    \n    XT_EKS = abc$mu\n    sd_EKS = apply(xyz$P, 3, diag)\n    sd_EKS = sqrt(sd_EKS)\n    sd_EKS[is.na(sd_EKS)]=0\n    sd_EKS = t(sd_EKS)\n    Xt_eks = array(0,dim=c(dim(Xt_real),sample_nums))\n    for (i in c(1:nrow(Xt_real))) {\n        Xt_eks[i,,]=t(rmvnorm(n=sample_nums,mean = XT_EKS[i,],sigma = diag(sd_EKS[i,])))[1:25,]\n    }\n    \n    #boxplot\n    if (TRUE) {\n        #Xt_all contains 100 trajectories (1k particles per run, 1 trajectory per run)\n        Xt_particle = Xt_all[,,1]\n        \n        group = 2\n        text = c('PF','EKF','EKS')\n        time_period=c(1:1440)\n        tt = seq(from=1,to=23,by=2)*60\n        Xt_particle = Xt_all[tt,,]\n        Xt_ekf = Xt_ekf[tt,,]\n        Xt_eks = Xt_eks[tt,,]\n        \n        lanes = sample(c(1:25),5)\n        lanes = unique(c(lanes,1,2))\n        for (plot_lane in lanes) {\n            print(plot_lane)\n            \n            boxthis = {}\n            seq1 = {}\n            seq2 = {}\n            label = {}\n            for (i in c(1:nrow(Xt_particle))) {\n                #tmp_box = c(Xt_particle[i,plot_lane,],Xt_ekf[i,plot_lane,])\n                tmp_box = c(Xt_particle[i,plot_lane,],Xt_ekf[i,plot_lane,],Xt_eks[i,plot_lane,])\n                tmp_seq2 = rep(c(1:group),each=(length(tmp_box)/group))\n                boxthis = c(boxthis,tmp_box)\n                seq2 = c(seq2,tmp_seq2)\n            }\n            \n            seq1 = rep(c(1:12),each=(length(boxthis)/12))\n            #seq2 = rep(c(1:3),each=(length(boxthis)/3))\n            label = interaction(seq1,seq2)\n            \n            seq1 = factor(seq1)\n            seq2 = factor(seq2)\n            method = seq2\n            levels(method) = text[1:group]\n            target = data.frame(boxthis,label,seq1,method)\n            a = ggplot() + geom_boxplot(aes(y = boxthis, x = seq1,fill=method), data = target) + labs(title = \"Boxplot of PF,EKF and EKS\",x='time period',y='number of vehicles')\n            \n            #add groundtruth\n            x=seq(from=1,to=12,length.out =length(time_period))\n            y=Xt_real[time_period,plot_lane]\n            x2=seq(from=1,to=12,length.out =length(boxthis))\n            y2 = approx(x=x,y=y,xout=x2,method = 'linear')[[2]]\n            y2 = SMA(y2,100)\n            y2 = c(rep(y2[100],99),y2[100:length(y2)])\n            ground_truth = data.frame(x=x2,y=y2)\n            a + geom_line(data = ground_truth, aes_string(x=ground_truth$x, y=ground_truth$y),col='black')\n            \n            name = paste('ob3to25',plot_lane,sep='_')\n            name = paste(name,'jpg',sep = '.')\n            dev.copy(file=name, device=jpeg, quality=100, width=1024, height=1024)\n            dev.off()\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1473430492991.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3689605781",
    "id" : "AE7F00C9",
    "lastKnownWriteTime" : 1473437880,
    "last_content_update" : 1473437880,
    "path" : "~/Documents/R/kalman_filtering/1_berlin/KF2.R",
    "project_path" : "KF2.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}