{
    "collab_server" : "",
    "contents" : "library(data.table)\n\n#functions\nLocation <- function(events,network) {\n  #types <- as.character(levels(events$activity.start$type))\n  types <- unique(events$activity.end$type)\n  links <- rownames(network$e)\n  locations <- c(types,links)\n  return(locations)\n}\n\nPersonStateT <- function(events,extend) {\n  #types <- levels(events[[4]]$type)\n  types <- unique(events[[4]]$type)\n  min.time <- min(sapply(1:length(events),function(n) min(events[[n]]$time[!is.infinite(events[[n]]$time)])))\n  max.time <- min(min.time+24*3600,max(sapply(1:length(events),function(n) max(events[[n]]$time[!is.infinite(events[[n]]$time)]))))\n  delta.t <- 60\n  td <- seq(from=min.time, to=max.time+delta.t-1, by=delta.t)\n  \n  person.state.d <- matrix(0,nrow = length(td), ncol = length(unique(activity.end$person)))\n  person.state.d[1,] <- 'h'\n  ndx <- integer(length=length(events))\n  ndx[] <- 1\n  ctime <- min.time\n  last <- 1\n  \n  while(any(ndx<sapply(events, nrow))){\n    ctime <- min(sapply(1:length(events),function(n) events[[n]]$time[ndx[n]] ))\n    if(ctime > max.time)\n      break\n    ndx0 <- which(td>=ctime)[1]\n    if (ndx0 > last) {\n      #print(ndx0)\n      for(i in c((last+1):ndx0)) {\n        person.state.d[i,] <- person.state.d[last,]\n      }\n    }\n    # update site state according to events\n    switch(which.min(sapply(1:length(events),function(n)events[[n]]$time[ndx[n]] )),\n           {# activity end\n             #person.state[ndx0, events[[1]]$person[ndx[1]] ] =  events[[1]]$link[ndx[1]]\n             ndx[1]<-ndx[1]+1\n           },\n           {# link.leave\n             ndx[2]<-ndx[2]+1\n           },\n           {# link.enter\n             person.state.d[ndx0, as.numeric(events[[3]]$person[ndx[3]]) ] <-  events[[3]]$link[ndx[3]] \n             ndx[3]<-ndx[3]+1\n           },\n           {# activity.start\n             person.state.d[ndx0, as.numeric(events[[4]]$person[ndx[4]]) ] <-  as.character(events[[4]]$type[ndx[4]])\n             ndx[4]<-ndx[4]+1\n           })\n    #person.state.d[ndx0+1,] = person.state.d[ndx0,]\n    last <- ndx0\n  }\n  #person.state.d <- matrix(as.numeric(factor(person.state.d, levels=c('h','w',rownames(e)))), nrow=nrow(person.state.d))\n  #inc\n  if (extend) {\n    person.state.d[ndx0:nrow(person.state.d),] = person.state.d[ndx0]\n    inc1 = trunc(min(td)/60)\n    inc2 = 1440-trunc(max(td)/60)\n    td <- c(c(1:inc1)*60,td,c(1:inc2)*60+trunc(max(td)))\n    person.state.d <- rbind(array('h',dim=c(inc1,ncol(person.state.d))),person.state.d,array('h',dim=c(inc2,ncol(person.state.d))))\n    \n  }\n  return(list(person.state.d=person.state.d,td=td))\n}\n\nMTime <- function(person.state.d,td,locations,smoother) {\n  m <- table(factor(head(person.state.d,-1),levels=locations), factor(tail(person.state.d,-1),levels=locations))\n  m <- sweep(m, 1, STATS=rowSums(m), FUN='/')\n  rownames(m) <- colnames(m) <- locations\n  \n  m.time <- table(factor(head(person.state.d,-1),levels=locations), factor(tail(person.state.d,-1),levels=locations),cut(td[row(head(person.state.d,-1))]/3600,breaks = 0:24*1))\n  m.time <- sweep(m.time*smoother, MARGIN = 1:2, STATS = table(factor(head(person.state.d,-1),levels=locations), factor(tail(person.state.d,-1),levels=locations))*(1-smoother), FUN = '+')\n  m.time <- sweep(m.time, MARGIN = c(1,3), STATS = colSums(aperm(m.time,perm = c(2,1,3)),dims = 1),FUN = '/')\n  dimnames(m.time)[[1]] <- dimnames(m.time)[[2]] <- locations\n  \n  return(list(m=m,m.time=m.time))\n}\n\nYT <- function(person.state.d,scale,locations) {\n  numbers <- dim(person.state.d)[2]\n  probe.person <- sample.int(ncol(person.state.d),trunc(ncol(person.state.d)/scale))\n  Yt <- person.state.d[,probe.person]\n  return(list(probe.person=probe.person,Yt=Yt))\n}\n\nLogObsMatrix <- function(obs.scale,N) {\n  n <- trunc(N/obs.scale)\n  obs.matrix <- array(0,dim = c(N+1,n+1))\n  c <- lchoose(N,n)\n  for (i in c(1:nrow(obs.matrix))) {\n    M <- i-1\n    m <- c(0:n)\n    a <- lchoose(M,m)\n    b <- lchoose(N-M,n-m)\n    d <- a+b-c\n    obs.matrix[i,] <- exp(d)\n  }\n  obs.matrix <- pmax(obs.matrix, 1e-300)\n  obs.matrix <- log(obs.matrix)\n}\n\n#constructing prerequisite matrices\nif (TRUE) {\n  #load data\n  \n  load('data_exec/equil.RData') \n  network = readRDS('data_exec/network.RDS')\n  e=network$e\n  n=network$n\n  \n  # events\n  events = list(activity.end = activity.end, link.leave = link.leave, link.enter = link.enter, activity.start = activity.start)\n  invisible(lapply(1:length(events), function(n) if(!is.infinite(events[[n]]$time[nrow(events[[n]])])){\n    events[[n]] <<- events[[n]][order(events[[n]]$time),]\n    events[[n]] <<- rbind(events[[n]], tail(events[[n]],1))\n    events[[n]]$time[nrow(events[[n]])] <<- Inf\n  }))\n  \n  extend = 1\n  locations = Location(events,network)\n  person.track = PersonStateT(events,extend)\n  person.state.d = person.track$person.state.d\n  td = person.track$td\n  observation = YT(person.state.d,40,locations)\n  Yt = observation$Yt\n  probe.person = observation$probe.person\n  transition =MTime(person.state.d,td,locations,(1-1e-6))\n  m.time = transition$m.time\n  \n  person.state.d = Yt\n  Xt_real = t(apply(person.state.d,1,function(x) table(factor(x, levels=locations))))\n  \n  save(Xt_real,file='data_result1/Xt_real.RData')\n  save(probe.person,file = 'data_result1/probe.person.RData')\n  save(td,file='data_result1/td.RData')\n  save(person.state.d,file='data_result1/person.state.d.RData')\n  save(m.time,file='data_result1/m.time.RData')\n  save(locations,file='data_result1/locations.RData')\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1525974724007.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "516337570",
    "id" : "A1E4AE46",
    "lastKnownWriteTime" : 1517946973,
    "last_content_update" : 1517946973,
    "path" : "~/Documents/R/RL_VI_2018_NIPS/vi_prep3_50_a=v/prep1_equil_pf.R",
    "project_path" : "prep1_equil_pf.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}