{
    "collab_server" : "",
    "contents" : "library('Matrix')\nrequire('TTR')\nrequire('igraph')\nrequire('survey')\nrequire('grr')\nrequire('graphics')\nrequire('RcppEigen')\nrequire('Rcpp')\nrequire('deldir')\n\n#construct event\nif (TRUE) {\n  realdata = readRDS(file = \"data_prep/300.events.RDS\")\n  network = readRDS(file = \"data_prep/network.RDS\")\n  activity.end = realdata$activity.end\n  link.leave = realdata$leave\n  link.enter = realdata$enter\n  activity.start = realdata$activity.start\n  \n  # events\n  events = list(activity.end = activity.end, link.leave = link.leave, link.enter = link.enter, activity.start = activity.start)\n  invisible(lapply(1:length(events), function(n) if(!is.infinite(events[[n]]$time[nrow(events[[n]])])){\n    events[[n]] <<- events[[n]][order(events[[n]]$time),]\n    events[[n]] <<- rbind(events[[n]], tail(events[[n]],1))\n    events[[n]]$time[nrow(events[[n]])] <<- Inf\n  }))\n  ndx = integer(length=length(events))\n  ndx[] = 1\n  \n  # has problem, 4 person != 3 person, fixed\n  unique_person = c(levels(events[[1]]$person),levels(events[[2]]$person),levels(events[[3]]$person),levels(events[[4]]$person))\n  unique_person = unique_person[!duplicated(unique_person)]\n  unique_lane = rownames(network$e)\n  \n  events[[1]]$person = factor(events[[1]]$person,levels = unique_person)\n  events[[2]]$person = factor(events[[2]]$person,levels = unique_person)\n  events[[3]]$person = factor(events[[3]]$person,levels = unique_person)\n  events[[4]]$person = factor(events[[4]]$person,levels = unique_person)\n  events[[1]]$link = factor(events[[1]]$link,levels = unique_lane)\n  events[[2]]$link = factor(events[[2]]$link,levels = unique_lane)\n  events[[3]]$link = factor(events[[3]]$link,levels = unique_lane)\n  events[[4]]$link = factor(events[[4]]$link,levels = unique_lane)\n  \n  levels(events[[3]]$person) = c(1:length(unique_person))\n  levels(events[[4]]$person) = c(1:length(unique_person))\n  levels(events[[2]]$person) = c(1:length(unique_person))\n  levels(events[[1]]$person) = c(1:length(unique_person))\n  levels(events[[1]]$link) = c(1:length(unique_lane))\n  levels(events[[2]]$link) = c(1:length(unique_lane))\n  levels(events[[3]]$link) = c(1:length(unique_lane))\n  levels(events[[4]]$link) = c(1:length(unique_lane)) \n}\n\n# road cluster\nif (TRUE) {\n  network = readRDS(file = \"data_prep/network.RDS\")\n  e = network$e\n  n = network$n\n  \n  #method 1, assign 'e' to 'from'\n  net_data_frame = array(0,dim = c(nrow(e),2))\n  net_data_frame[,1] = match(e$from,rownames(n))\n  net_data_frame[,2] = match(e$to,rownames(n))\n  \n  net_graph = graph_from_data_frame(net_data_frame)\n  c_node <- cluster_walktrap(net_graph)\n  r_node = membership(c_node)\n  \n  # membership of edge, assigned to be same as 'from node'\n  r_edge = array(0,dim=nrow(e))\n  r_edge_from = net_data_frame[,1]\n  r_edge = r_node[match(r_edge_from,as.numeric(names(r_node)))]\n  \n  # cluster center location\n  cluster_location = array(0,dim=c(length(tabulate(r_node)),2))\n  for (i in c(1:length(r_node))) {\n    idx = as.numeric(names(r_node[i]))\n    cluster_location[r_node[i],1] = cluster_location[r_node[i],1] + n[idx,1]\n    cluster_location[r_node[i],2] = cluster_location[r_node[i],2] + n[idx,2]\n  }\n  cluster_location=cluster_location/tabulate(r_node)\n  \n  save(cluster_location,file='data_prep/cluster_location.RData')\n  save(r_edge,file = \"data_prep/r_edge.RData\")\n  save(r_node,file = \"data_prep/r_node.RData\")\n  \n  #compute major roads\n  if (FALSE) {\n    major_points = array(0,dim=c(length(major),4))\n    major_location = array(0,dim=c(length(major),2))\n    for (i in c(1:length(major))) {\n      start = which(rownames(n) == e$from[i])\n      end = which(rownames(n) == e$to[i])\n      major_location[i,1] = (n[start,1]+n[end,1])/2\n      major_location[i,2] = (n[start,2]+n[end,2])/2\n      major_points[i,1] = n[start,1]\n      major_points[i,2] = n[start,2]\n      major_points[i,3] = n[end,1]\n      major_points[i,4] = n[end,2]\n    }\n    save(major_points,file='major_points.RData')\n    save(major_location,file='major_location.RData') \n  }\n}\n\n\n\n\n\n#construct person.state.d\nif (TRUE) {\n  load(\"data_prep/r_edge.RData\")\n  network = readRDS(file = \"data_prep/network.RDS\")\n  e = nrow(network$e)\n  \n  types = levels(events[[4]]$type)\n  types = c(types,'road')\n  max.person = length(unique(activity.end$person))\n  min.time = min(sapply(1:length(events),function(n) min(events[[n]]$time[!is.infinite(events[[n]]$time)])))\n  \n  # 13860,93889\n  max.time = min.time+22*3600\n  delta.t = 60\n  td = seq(from=min.time, to=max.time, by=delta.t)\n  \n  #compute person.state.d, initial home? find person road\n  person.state.d = matrix(0,nrow = length(td), ncol = length(unique(activity.end$person)))\n  person.state.d[1,] = paste(types[1],0,sep = '@')\n  ndx = integer(length=length(events))\n  ndx[] = 1\n  ctime = min.time\n  last = 1\n  \n  while(any(ndx<sapply(events, nrow))){\n    ctime = min(sapply(1:length(events),function(n)events[[n]]$time[ndx[n]] ))\n    if(ctime > max.time)\n      break\n    ndx0 = which(td>=ctime)[1]\n    if (ndx0 > last) {\n      print(ndx0)\n      for(i in c((last+1):ndx0)) {\n        person.state.d[i,] = person.state.d[last,]\n      }\n    }\n    # update site state according to events\n    switch(which.min(sapply(1:length(events),function(n)events[[n]]$time[ndx[n]] )),\n           {# activity end\n             #person.state[ndx0, events[[1]]$person[ndx[1]] ] =  events[[1]]$link[ndx[1]]\n             ndx[1]=ndx[1]+1\n           },\n           {# link.leave\n             ndx[2]=ndx[2]+1\n           },\n           {# link.enter\n             person.state.d[ndx0, events[[3]]$person[ndx[3]] ] = paste(types[6],r_edge[events[[3]]$link[ndx[3]] ],sep = '@')\n             ndx[3]=ndx[3]+1\n           },\n           {# activity.start\n             person.state.d[ndx0, events[[4]]$person[ndx[4]] ] =  paste(as.character(events[[4]]$type[ndx[4]]), r_edge[events[[4]]$link[ndx[4]] ],sep = '@')\n             ndx[4]=ndx[4]+1\n           })\n    #person.state.d[ndx0+1,] = person.state.d[ndx0,]\n    last = ndx0\n  }\n  \n  #update home@0\n  for (i in c(1:ncol(person.state.d))) {\n    print(i)\n    t = sapply(1:length(events),function(n)events[[n]]$time[which(events[[n]]$person == i)[1]] )\n    t[is.na(t)] = Inf\n    b=which(person.state.d[,i]=='home@0')\n    c=r_edge[events[[which.min(t)]]$link[which(events[[which.min(t)]]$person == i)[1]]]\n    switch (which.min(t),\n            {\n              person.state.d[b,i] = paste(as.character(events[[1]]$type[which(events[[1]]$person == i)[1]]),c,sep = '@')\n            },\n            {\n              person.state.d[b,i] = paste('home',c,sep = '@')\n            },\n            {\n              person.state.d[b,i] = paste('home',c,sep = '@')\n            },\n            {\n              person.state.d[b,i] = paste('home',c,sep = '@')\n            }\n    )\n  }\n  \n  save(person.state.d,file = \"data_prep/person.state.d.RData\") \n}\n\n#transition matrix m.time\nif (TRUE) {\n  types_a = rep(types,each=length(table(r_edge)))\n  types_b = rep(c(1:length(table(r_edge))),times = length(types))\n  types = paste(types_a,types_b,sep='@')\n  \n  a = factor(head(person.state.d,-1),levels = c(types))\n  b = factor(tail(person.state.d,-1),levels = c(types))\n  m = table(factor(head(person.state.d,-1),levels=c(types)), factor(tail(person.state.d,-1),levels=c(types)))\n  m = sweep(m, 1, STATS=rowSums(m), FUN='/')\n  m[is.nan(m)] = 0\n  save(m,file=\"data_exec/m.RData\")\n  \n  m.time = table(factor(head(person.state.d,-1),levels=c(types)), factor(tail(person.state.d,-1),levels=c(types)),cut(td[row(head(person.state.d,-1))]/3600,breaks = 0:23+trunc(min(td)/3600)))\n  #m.time = sweep(m.time*.99, MARGIN = 1:2, STATS = table(c(head(person.state.d,-1)), c(tail(person.state.d,-1)))*.01, FUN = '+')\n  m.time = sweep(m.time*.9999, MARGIN = 1:2, STATS = table(factor(head(person.state.d,-1),levels=c(types)), factor(tail(person.state.d,-1),levels=c(types)))*.0001, FUN = '+')\n  m.time = sweep(m.time, MARGIN = c(1,3), STATS = colSums(aperm(m.time,perm = c(2,1,3)),dims = 1),FUN = '/')\n  dimnames(m.time)[[1]] = dimnames(m.time)[[2]] = c(types)\n  save(m.time,file = \"data_exec/m.time.RData\") \n}\n\n#generate Xt_real\nif (TRUE) {\n  Xt_real = t(apply(person.state.d,1,function(x) table(factor(x, levels=types)))) \n  save(Xt_real,file='data_exec/Xt_real.RData')\n}\n\n#generate Yt\nif (FALSE) {\n  numbers = ncol(Xt_real)\n  scale = 10\n  probe.person = sample.int(ncol(person.state.d),trunc(ncol(person.state.d)/scale))\n  save(probe.person,file='data_exec/probe.person.fan.10.RData')\n  Yt = array(0,dim=c(nrow(person.state.d),numbers))\n  person.probe.d = person.state.d[,probe.person]\n  Yt = t(apply(person.probe.d,1,function(x) table(factor(x, levels=types)))) \n  save(Yt,file = 'data_exec/Yt.RData')\n}\n\n#log obs.matrix\nif (TRUE) {\n  #log obs.matrix\n  obs.scale = 10\n  N = 2200\n  n = trunc(N/obs.scale)\n  obs.matrix = array(0,dim = c(N+1,n+1))\n  c = lchoose(N,n)\n  for (i in c(1:nrow(obs.matrix))) {\n    M = i-1\n    m = c(0:n)\n    a = lchoose(M,m)\n    b = lchoose(N-M,n-m)\n    d = a+b-c\n    obs.matrix[i,] = exp(d)\n  }\n  \n  obs.matrix = pmax(obs.matrix, 1e-300)\n  obs.matrix = log(obs.matrix)\n  save(obs.matrix,file = \"data_exec/obs.matrix.RData\")\n  \n  image(z=t(asinh(1000*obs.matrix)),x=1:ncol(obs.matrix) -1, y=1:nrow(obs.matrix) -1,xlab='# oberved vehicles scaled', ylab='# vehicles', asp=1)\n}\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1472390173836.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2830719332",
    "id" : "C564C484",
    "lastKnownWriteTime" : 1472518255,
    "last_content_update" : 1472518255234,
    "path" : "~/Documents/R/particle_filtering/1_Berlin/bench_berlin3/prep_cluster.R",
    "project_path" : "prep_cluster.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}